# Indicates exactly one field must be supplied and this field must not be `null`.
directive @oneOf on INPUT_OBJECT

type WidgetParamsGQL {
  courseIds: [ID!]
  courseId: ID
  userId: ID
  maxLateAssignments: Float
  maxMissingAssignments: Float
  minLowScorePercentage: Float
  delayDaysAfterAction: Float
  year: Float
  month: Float
}

type AssetLinkGQL {
  id: ID!
  assetId: Float!
  assetType: String!
  courseId: ID!
  contentLibraryCourseId: ID!
  detached: Boolean!
  createdAt: DateTime!
}

# A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
scalar DateTime

type ContentLibraryGQL {
  id: ID!
  accountId: ID!
  courseId: ID!
  externalLinksModuleId: ID
  externalToolsModuleId: ID
}

type ContentVersionGQL {
  id: ID!
  assetId: Float!
  assetType: AssetTypeEnum!
  contentExportId: String!
  title: String!
  createdAt: DateTime!
  courseId: ID
}

enum AssetTypeEnum {
  assignment
  discussion_topic
  page
  quiz
  module
  module_item
  external_url
  external_tool
  file
}

type ContentVersionPreviewGQL {
  url: String
}

type CrmJwtGQL {
  # JWT for CRM integration configuration
  token: String!
}

type WidgetGroupGQL {
  id: ID!
  name: String
  description: String
  createdAt: DateTime!
  widgets: [WidgetGQL!]
}

type WidgetGQL {
  id: ID!
  type: String!
  queryParams: WidgetParamsGQL!
  position: Int
  prismQueryId: String
  createdAt: DateTime!
  updatedAt: DateTime!
  group: WidgetGroupGQL
}

type WidgetActionGQL {
  id: ID!
  action: String!
  canvasUserUuid: String!
  courseId: String!
  actionReason: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WidgetDataResultGQL {
  # The most recent last modified timestamp among the underlying S3 objects used for this widget data
  lastModifiedDate: DateTime

  # The widget data array (unchanged from the legacy getWidgetData)
  data: [JSON!]!
}

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

type WidgetGroupUserDataGQL {
  id: ID!
  widgetGroupId: ID!
  isPinned: Boolean!
  lastCheckedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InsightActionModel {
  id: ID!
  type: String!
  status: String!
  errors: [String!]
  issuedAt: DateTime!
  input: InsightActionInputModel!
}

union InsightActionInputModel =
    EncourageLearnersInput
  | PraiseLearnersInput
  | RemindLearnersInput

type EncourageLearnersInput {
  subject: String!
  body: String!
  learner_ids: [String!]!
  sendIndividualMessages: Boolean!
}

type PraiseLearnersInput {
  subject: String!
  body: String!
  learner_ids: [String!]!
  sendIndividualMessages: Boolean!
}

type RemindLearnersInput {
  subject: String!
  body: String!
  course_id: String
  learner_ids: [String!]!
  sendIndividualMessages: Boolean!
}

type InsightMessageModel {
  id: ID!
  type: String!
  status: String!

  # Time at which the message had new data
  generatedAt: DateTime!

  # Time at which this message had its status last transitioned
  updatedAt: DateTime!
  date: DateTime! @deprecated(reason: "Use generatedAt instead")
  rootAccountId: String!
  accountId: String!
  data: InsightMessageDataModel!
}

union InsightMessageDataModel =
    LearnersDidCompleteCourse
  | LearnersDidGainSkills
  | LearnersDidNotStartCourseYet
  | LearnersDidReturnAfterIdling
  | LearnersInCourseAreIdling
  | MostPopularSkill
  | PlatformEngagementTrend

type LearnersDidCompleteCourse {
  course_id: String!
  learner_ids: [String!]!
}

type LearnersDidGainSkills {
  skill_count: Float!
  learner_ids: [String!]!
}

type LearnersDidNotStartCourseYet {
  course_id: String!
  learner_ids: [String!]!
}

type LearnersDidReturnAfterIdling {
  learner_ids: [String!]!
}

type LearnersInCourseAreIdling {
  course_id: String!
  learner_ids: [String!]!
}

type MostPopularSkill {
  skill_name: String!
}

type PlatformEngagementTrend {
  trend: Float!
}

type UserMetadataGQL {
  # Unique identifier for the user metadata
  id: ID!

  # ID of the associated metadata user
  userId: ID!

  # Key for the metadata
  key: String!

  # Value for the metadata
  value: String!

  # Timestamp when the record was created
  createdAt: DateTime!

  # Timestamp when the record was last updated
  updatedAt: DateTime!

  # Associated metadata user
  user: MetadataUserGQL
}

type MetadataUserGQL {
  # Unique identifier for the metadata user; internal to the metadata service
  id: ID!

  # UUID of the user's Canvas root account
  canvasRootAccountUuid: ID!

  # User's Canvas UUID
  canvasUserUuid: ID!

  # List of user's leaders Canvas UUIDs
  leaderCanvasUserUuids: [ID!]

  # Timestamp when the record was created
  createdAt: DateTime!

  # Timestamp when the record was last updated
  updatedAt: DateTime!

  # List of this user's metadata
  metadata: [UserMetadataGQL!]
}

type MetadataUsersGql {
  # List of users
  users: [MetadataUserGQL!]!
}

type CursorPaginationInfoGQL {
  # Cursor for the next page
  nextCursor: String

  # Cursor for the previous page
  previousCursor: String

  # Whether there is a next page
  hasNextPage: Boolean!

  # Whether there is a previous page
  hasPreviousPage: Boolean!
}

type LearningLibraryGQL {
  id: String!

  # Internal name of the learning library collection
  name: String!

  # Public-facing name of the collection
  publicName: String
  description: String
  publishStatus: LearningLibraryPublishStatus!
  ownerId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

# Publish status of learning library collection
enum LearningLibraryPublishStatus {
  UNPUBLISHED
  PUBLISHED
  ARCHIVED
  DELETED
}

type LearningLibraryCollectionsCursorResponseGQL {
  # List of Learning Library Collections
  collections: [LearningLibraryGQL!]!

  # Cursor-based pagination information
  pageInfo: CursorPaginationInfoGQL!
}

type LearningLibraryCollectionEnrollmentGQL {
  # Enrollment ID
  id: String!

  # Learning library collection ID
  collectionId: String!

  # User ID of the enrollee
  enrolleeId: String!

  # Enrollment status
  status: LearningLibraryCollectionEnrollmentStatus!

  # When the user enrolled
  enrolledAt: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

# Enrollment status for learning library collection
enum LearningLibraryCollectionEnrollmentStatus {
  ACTIVE
  INACTIVE
}

type PaginationInfoGQL {
  # Current page number (1-indexed)
  currentPage: Int!

  # Total number of pages available
  totalPages: Int

  # Whether there is a next page
  hasNextPage: Boolean!

  # Whether there is a previous page
  hasPreviousPage: Boolean!
}

type CanvasUserGQL {
  # Canvas user ID
  id: ID!

  # User name from Canvas
  name: String

  # User email from Canvas
  email: String

  # User sortable name from Canvas
  sortableName: String

  # User short name from Canvas
  shortName: String

  # User login ID from Canvas
  loginId: String

  # User avatar URL from Canvas
  avatarUrl: String

  # Canvas user UUID
  uuid: String

  # SIS user ID from Canvas
  sisUserId: String

  # Integration ID from Canvas
  integrationId: String
}

type KeyValuePairGQL {
  # Metadata key
  key: String!

  # Metadata value
  value: String!
}

type PersonGQL {
  # Canvas user ID
  id: ID!

  # User name from Canvas
  name: String

  # User email from Canvas
  email: String

  # User sortable name from Canvas
  sortableName: String

  # User short name from Canvas
  shortName: String

  # User login ID from Canvas
  loginId: String

  # User avatar URL from Canvas
  avatarUrl: String

  # Canvas user UUID
  uuid: ID

  # SIS user ID from Canvas
  sisUserId: String

  # Integration ID from Canvas
  integrationId: String

  # User metadata from Journey
  metadata: [KeyValuePairGQL!]

  # Leaders for this user from Canvas
  leaders: [CanvasUserGQL!]

  # Number of direct subordinates for this user from Canvas
  subordinateCount: Float

  # User timezone from Canvas
  timeZone: String

  # Last login timestamp from Canvas
  lastLogin: String

  # Account UUID from Journey metadata
  accountUuid: String!
}

type PeopleResponseGQL {
  # List of people (Canvas users enriched with metadata)
  people: [PersonGQL!]!

  # Pagination information for the query
  pagination: PaginationInfoGQL!
}

type SkillTaxonomyGroupGQL {
  # Unique identifier for the group
  id: ID!

  # Name of the skill taxonomy group
  name: String!

  # Creation date of the group
  createdAt: DateTime!

  # Last updated date of the group
  updatedAt: DateTime!

  # Account associated with the skill taxonomy group
  account: SkillTaxonomyAccountGQL

  # Skills associated with the skill taxonomy group
  taxonomySkills: [SkillTaxonomySkillGQL!]!
}

type SkillTaxonomyAccountGQL {
  # Unique identifier for the account
  id: ID!

  # Root account UUID for the skill taxonomy
  rootAccountUuid: String!

  # Creation date of the skill taxonomy account
  createdAt: DateTime!

  # Groups associated with the skill taxonomy account
  groups: [SkillTaxonomyGroupGQL!]!

  # Skills associated with the skill taxonomy account
  taxonomySkills: [SkillTaxonomySkillGQL!]!
}

type SkillTaxonomySkillGQL {
  # Unique identifier for the skill
  id: ID!

  # Name of the skill
  name: String!

  # Description of the skill
  description: String

  # Creation date of the skill
  createdAt: DateTime!

  # Last updated date of the skill
  updatedAt: DateTime!

  # Group to which the skill belongs
  group: SkillTaxonomyGroupGQL

  # Account associated with the skill
  account: SkillTaxonomyAccountGQL
  courses: [SkillTaxonomyCourseGQL!]!
  programs: [ProgramGQL!]!
  alignmentsGroupedByProficiencyScaleValue(
    courseId: String!
  ): [AlignmentsByProficiencyScaleValueGQL!]!
  coursesGroupedByProficiencyScaleValue(
    programId: String!
  ): [CoursesByProficiencyScaleValueGQL!]!
}

type PopulatedSimilarSkillGQL {
  # Unique identifier for the skill
  id: ID

  # Name of the skill
  name: String!

  # Description of the skill
  description: String

  # Creation date of the skill
  createdAt: DateTime!

  # Last updated date of the skill
  updatedAt: DateTime!

  # Group to which the skill belongs
  group: SkillTaxonomyGroupGQL

  # Account associated with the skill
  account: SkillTaxonomyAccountGQL
  courses: [SkillTaxonomyCourseGQL!]!
  programs: [ProgramGQL!]!
}

type SkillTaxonomyProficiencyScaleValueGQL {
  # Unique identifier for the proficiency scale value
  id: ID!

  # Level of the proficiency scale value
  level: Int!

  # String value of the proficiency scale value
  value: String!
}

type SkillTaxonomyCourseGQL {
  # Unique identifier for the course
  id: ID!

  # Unique identifier for the course in Canvas
  courseId: String!

  # Learning objects associated with the course
  learningObjects: [SkillTaxonomyLearningObjectGQL!]!
  uniqueSkills: Float!
  skills(moduleId: String, moduleItemId: String): [SkillTaxonomySkillGQL!]!
}

type SkillTaxonomyLearningObjectGQL {
  # Unique identifier for the learning object
  id: String!

  # Content ID of the learning object
  contentId: String!

  # Type of the learning object
  type: String!

  # Alignments of the learning object with skills
  alignments: [SkillTaxonomySkillAlignmentGQL!]!

  # Course associated with the learning object
  course: SkillTaxonomyCourseGQL
}

type SkillTaxonomySkillAlignmentGQL {
  # Unique identifier for the skill alignment
  id: ID!

  # Module identifier for the skill alignment
  moduleId: String!

  # Module item identifier for the skill alignment
  moduleItemId: String!

  # Skill associated with the alignment
  skill: SkillTaxonomySkillGQL

  # Proficiency scale values for the skill alignment
  proficiencyScaleValues: [SkillTaxonomyProficiencyScaleValueGQL!]!

  # Learning object associated with the skill alignment
  learningObject: SkillTaxonomyLearningObjectGQL
}

type AlignmentsByProficiencyScaleValueGQL {
  # Proficiency scale value for the skill alignment
  proficiencyScaleValue: SkillTaxonomyProficiencyScaleValueGQL

  # List of skill alignments for the proficiency scale value
  alignments: [SkillTaxonomySkillAlignmentGQL!]!
}

type AssociateSkillsToLearningObjectsResultGQL {
  # List of alignments that were successfully persisted
  persistedAlignments: [SkillTaxonomySkillAlignmentGQL!]!

  # List of alignment IDs that were deleted
  deletedAlignments: [ID!]!
}

type SimilarSkillGroupGQL {
  # List of similar skills in the group
  similarSkills: [PopulatedSimilarSkillGQL!]!
}

type ChangeTaxonomySkillsResultGQL {
  # List of similar skill groups found in the taxonomy
  similarSkillGroups: [SimilarSkillGroupGQL!]!

  # List of skills that were successfully persisted to the taxonomy
  persistedSkills: [SkillTaxonomySkillGQL!]!

  # List of skill IDs that were deleted from the taxonomy
  deletedSkills: [ID!]
}

type CoursesByProficiencyScaleValueGQL {
  # Proficiency scale value specified in the alignment for the skill
  proficiencyScaleValue: SkillTaxonomyProficiencyScaleValueGQL

  # List of courses for the proficiency scale value
  courses: [SkillTaxonomyCourseGQL!]!
}

type SkillTaxonomyProficiencyScaleGQL {
  # Unique identifier for the proficiency scale
  id: ID!

  # Name of the proficiency scale
  name: String!

  # Root account UUID for the proficiency scale
  rootAccountUuid: String

  # Values associated with the proficiency scale
  values: [SkillTaxonomyProficiencyScaleValueGQL!]!
}

type ProgramGQL {
  id: String!

  # Internal name of the program
  name: String!

  # Public-facing name of the program
  publicName: String

  # Custom ID associated by the creator
  customerId: String
  description: String
  publishStatus: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  owner: String!
  startDate: DateTime
  endDate: DateTime

  # Program variant type (linear or non-linear)
  variant: ProgramVariantType!

  # Number of courses required for completion in non-linear programs
  courseCompletionCount: Int

  # Course enrollment type for the program
  courseEnrollment: CourseEnrollmentType!
  requirements: [ProgramRequirementGQL!]!
  enrollments: [ProgramEnrollmentGQL!]!
  progresses: [ProgramProgressGQL!]!
  uniqueSkills: Float!
  skills: [SkillTaxonomySkillGQL!]!
}

# Type of program variant (linear or non-linear)
enum ProgramVariantType {
  LINEAR
  NON_LINEAR
}

# Type of course enrollment (self-enrollment or auto-enrollment)
enum CourseEnrollmentType {
  AUTO
  SELF
}

type ProgramEnrollmentGQL {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  enrollee: String!
}

type ProgramCourseGQL {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  canvasCourseId: String!
  canvasUrl: String!
  canvasCourseName: String
  canvasCourseImageUrl: String
  canvasMetadataUpdatedAt: DateTime
}

type ProgramRequirementGQL {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  isCompletionRequired: Boolean!
  isPlaceholder: Boolean!
  description: String

  # Course enrollment type for this requirement
  courseEnrollment: String!
  dependency: ProgramCourseGQL
  dependent: ProgramCourseGQL!
}

type ProgramProgressGQL {
  id: String!
  requirement: ProgramRequirementGQL!
  enrollment: ProgramEnrollmentGQL!
  completionPercentage: Float!
  courseEnrollmentStatus: ProgramProgressCourseEnrollmentStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ProgramProgressCourseEnrollmentStatus {
  ENROLLED
  NOT_ENROLLED
  BLOCKED
}

type ForceProgressRecalcResultGQL {
  updated: [String!]!
  failed: [String!]!
}

type RedwoodResponseGQL {
  # GraphQL response data from Redwood
  data: JSON

  # GraphQL errors from Redwood (if any)
  errors: [JSON!]
}

type ExtractedSkillGQL {
  name: String!
}

type SkillGQL {
  id: String!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  taxonomySkill: SkillTaxonomySkillGQL
  experiences: [ExperienceGQL!]!
  proficiencyLevel: String
}

type UserGQL {
  id: String!
  canvasId: String!
  canvasBaseUrl: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  isOnboarded: Boolean!
}

type CourseRecommendationGQL {
  courseId: Float!
  skills: [ExtractedSkillGQL!]!
}

type CourseRecommendationsGQL {
  recommendedCourses: [CourseRecommendationGQL!]!
}

type ExperienceGQL {
  id: String!
  type: String!
  status: String!
  skill: SkillGQL
  createdAt: DateTime!
  updatedAt: DateTime!
  fileName: String
  alignment: SkillTaxonomySkillAlignmentGQL
}

type Query {
  skill(id: String!): SkillGQL
  skills(completedOnly: Boolean): [SkillGQL!]!
  courseRecommendations(
    proficiencyLevel: String
    skillIds: [String!]! = []
  ): CourseRecommendationsGQL!
  adminUsers(canvasBaseUrl: String!): [UserGQL!]!
  currentUser: UserGQL!

  # Fetch all skills within the taxonomy for the given account
  skillTaxonomySkills(accountId: String!): [SkillTaxonomySkillGQL!]!

  # Fetch all available proficiency scales
  availableProficiencyScales(
    accountId: String!
  ): [SkillTaxonomyProficiencyScaleGQL!]!

  # Fetch the currently used proficiency scale for the account
  currentlyUsedProficiencyScale: SkillTaxonomyProficiencyScaleGQL
  skillTaxonomyGroups(accountId: String!): [SkillTaxonomyGroupGQL!]!
  skillTaxonomyCourses(courseIds: [String!]!): [SkillTaxonomyCourseGQL!]!
  skillTaxonomyCourse(courseId: String!): SkillTaxonomyCourseGQL!

  # Check if skill extraction has run for course/module/module item
  hasSkillExtractionRun(input: SkillExtractionStatusInputGQL!): Boolean!
  contentLibraries(accountId: ID!): [ContentLibraryGQL!]!
  contentLibrary(courseId: ID!): ContentLibraryGQL!
  contentVersions(
    assetId: Float
    assetType: AssetTypeEnum!
    courseId: ID!
  ): [ContentVersionGQL!]!
  currentContentVersions(
    assetType: AssetTypeEnum!
    courseId: ID!
  ): [ContentVersionGQL!]!
  previewContentVersion(id: ID!): ContentVersionPreviewGQL!
  assetLinks(
    assetId: Float!
    assetType: AssetTypeEnum!
    contentLibraryCourseId: ID!
  ): [AssetLinkGQL!]!
  assetLinkByAssetId(
    assetId: ID!
    assetType: AssetTypeEnum!
    contentLibraryId: ID!
  ): AssetLinkGQL

  # All programs available for the user to administer, optionally filtered by progress state
  programs(
    # Filter programs by progress state
    filter: ProgramFilterInput
  ): [ProgramGQL!]!

  # A program by id
  program(programId: String!): ProgramGQL!

  # All user enrolled programs
  enrolledPrograms: [ProgramGQL!]!

  # Get Learning Library Collections with cursor-based pagination support
  learningLibraryCollections(
    input: LearningLibraryCollectionsCursorQueryInput
  ): LearningLibraryCollectionsCursorResponseGQL!
  crmConfigJwt: CrmJwtGQL!
  testSnowflakeQuery: JSON!
  getSnowflakeQueryStatus(queryId: String!): String!
  getSnowflakeQueryResults(queryId: String!): JSON!
  readCsvFile(key: String!): JSON!
  widgetFileUrl(key: String!): String!
  widgetData(
    widgetType: String!
    dataScope: String!
    timeSpan: TimeSpanInput!
    canvasAccountId: String
    queryParams: WidgetDataFiltersInput
  ): WidgetDataResultGQL!
  widgetsByUser(userAccountId: String!): [WidgetGQL!]!
  widgetByTypeAndUser(userAccountId: String!, type: String!): WidgetGQL
  widgetGroupsByUser(userAccountId: String!): [WidgetGroupGQL!]!
  widgetGroupById(widgetGroupId: String!): WidgetGroupGQL!
  widgetActions(widgetId: String!): [WidgetActionGQL!]!
  widgetGroupUserDataByUser(userAccountId: String!): [WidgetGroupUserDataGQL!]!

  # Get users (and metadata) matching the specified criteria
  users(input: UsersQueryInputGQL!): MetadataUsersGql!

  # Get all distinct metadata key-value pairs for a given account
  distinctMetadataValues(input: UsersQueryInputGQL!): [UserMetadataGQL!]!

  # Get users (and metadata) reporting to a specified user or the current user
  userSubordinates(input: UserReportsQueryInputGQL!): MetadataUsersGql!

  # Get people (Canvas users enriched with metadata) from a specific account
  getPeople(input: PeopleQueryInputGQL!): PeopleResponseGQL!

  # Get people (Canvas users enriched with metadata) by their Canvas UUIDs from a specific account
  getPeopleByUuid(input: PeopleByUuidQueryInputGQL!): PeopleResponseGQL!

  # Retrieve all insight feed messages for the current user in a specific account.
  insights(
    account: String!

    # Data scope for insights (e.g., admin, leader, instructor, designer, ta)
    scope: String = "admin"
  ): [InsightMessageModel!]!
  insightActionLog(account: String!): [InsightActionModel!]!
  insightAction(action: String!): InsightActionModel
}

input SkillExtractionStatusInputGQL {
  # Canvas course ID
  courseId: String!

  # Optional module ID
  moduleId: String

  # Optional module item ID
  moduleItemId: String
}

input ProgramFilterInput {
  # Filter by program publish status
  publishStatus: ProgramPublishStatus

  # Filter by program progress state
  progressState: ProgramProgressState
}

# The publish status of a program
enum ProgramPublishStatus {
  UNPUBLISHED
  PUBLISHED
  ARCHIVED
  DELETED
}

# The progress state of a program
enum ProgramProgressState {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
}

input LearningLibraryCollectionsCursorQueryInput {
  # Cursor for pagination (ID of the last item from previous page)
  cursor: String

  # Number of items to return (default: 10, max: 100)
  limit: Int = 20

  # Direction to paginate (true = forward/next, false = backward/previous)
  forward: Boolean = true
}

input TimeSpanInput {
  type: TimeSpanType!
  startDate: DateTime
  endDate: DateTime
}

enum TimeSpanType {
  TODAY
  PAST_7_DAYS
  PAST_30_DAYS
  PAST_YEAR
  CUSTOM
}

input WidgetDataFiltersInput {
  courseIds: [Float!]
  courseId: Float
  userId: String
  userUuids: [String!]
  maxLateAssignments: Float
  maxMissingAssignments: Float
  minLowScorePercentage: Float
  delayDaysAfterAction: Float
  year: Float
  month: Float
}

input UsersQueryInputGQL {
  # UUID of the Canvas root account
  rootAccountUuid: ID!

  # Canvas account ID to check permissions against
  accountId: String

  # Optional list of Canvas user UUIDs to filter by. If not provided, all users in the root account will be considered.
  canvasUserUuids: [ID!]

  # Optional filters to apply to user metadata. Only users with metadata matching ALL filters will be returned.
  metadataFilters: [MetadataFilterInputGQL!]
}

input MetadataFilterInputGQL {
  # Key to filter metadata by
  key: String!

  # Optional value to filter metadata by. If not provided, any value for the key will match.
  value: String
}

input UserReportsQueryInputGQL {
  # UUID of the Canvas root account
  rootAccountUuid: ID

  # Canvas account ID to check permissions against
  accountId: String

  # Canvas user UUID of the user whose reports to retrieve
  canvasUserUuid: ID

  # Whether to include indirect reports. If false, only direct reports are included.
  includeIndirectReports: Boolean! = false
}

input PeopleQueryInputGQL {
  # The Canvas account ID (sub-account or root account)
  accountId: ID!

  # Optional search term to filter users
  searchTerm: String

  # Optional flag to return only users who are leaders, will ignore search term if set to true
  returnOnlyLeaders: Boolean

  # Optional filters to apply to user metadata. Only users with metadata matching ALL filters will be returned.
  metadataFilters: [MetadataFilterInputGQL!]

  # Page number for pagination (1-indexed)
  page: Int
}

input PeopleByUuidQueryInputGQL {
  # The Canvas account ID (sub-account or root account)
  accountId: ID!

  # List of Canvas user UUIDs to fetch
  uuids: [String!]!
}

type Mutation {
  createSkills(input: CreateSkillsInputGQL!): [SkillGQL!]!
  startSkillExtractionTaskForUser: Boolean!
  adminDeleteSkills(skillIds: [String!]!): Boolean!
  adminDeleteExperiences(experienceIds: [String!]!): Boolean!
  adminRemoveUser(userId: String!): Boolean!

  # Change the skill taxonomy for the given account
  changeTaxonomySkills(
    input: ChangeTaxonomySkillsInputGQL!
  ): ChangeTaxonomySkillsResultGQL!
  associateSkillsToLearningObjects(
    input: AssociateSkillsToLearningObjectsInputGQL!
  ): AssociateSkillsToLearningObjectsResultGQL!
  upsertSkillTaxonomyGroups(
    input: UpsertSkillTaxonomyGroupsInputGQL!
  ): [SkillTaxonomyGroupGQL!]!
  sendEvent(input: EventInputGQL!): Boolean!
  createContentLibrary(accountId: ID!): ContentLibraryGQL!
  updateContentLibrary(args: ContentLibraryInputGQL!): ContentLibraryGQL!
  createContentVersion(
    assetId: Float!
    assetType: AssetTypeEnum!
    title: String!
    courseId: ID!
    syncSettings: SyncSettingsInputGQL!
  ): ContentVersionGQL!
  importContentVersion(
    courseId: ID!
    contentVersionId: ID!
    moduleId: ID!
    detached: Boolean!
  ): ID!

  # Create a new program
  createProgram(program: String, accountId: String): ProgramGQL!

  # Update program metadata
  updateProgramMetadata(
    metadata: UpdateProgramMetadataGQL!
    accountId: String
  ): ProgramGQL!

  # Delete a program
  deleteProgram(programId: String!, accountId: String): Boolean!

  # Duplicate an existing program
  duplicateProgram(programId: String!, accountId: String): ProgramGQL!

  # Unenroll a Journey user from a program
  unenrollUserFromProgram(
    enrollmentId: String!
    canvasUUID: String!
    accountId: String
  ): Boolean!

  # Enroll multiple Journey users to a program
  batchEnrollUserToProgram(
    programId: String!
    userIds: [String!]!
    accountId: String
  ): [ProgramEnrollmentGQL!]!

  # Enroll multiple Journey users to multiple programs
  batchEnrollUsersToPrograms(
    programIds: [String!]!
    enrolleeIds: [String!]!
    accountId: String
  ): [ProgramEnrollmentGQL!]!

  # Override program requirements
  updateProgramRequirements(
    programId: String!
    requirements: [UpdateProgramRequirementsRequirementGQL!]!
    accountId: String
  ): [ProgramRequirementGQL!]!

  # Enroll user to program requirement
  enroll(progressId: String!): ProgramProgressGQL!

  # Update learner program progresses. This will force recalculation of all progresses for the learner. It can be filtered by Canvas course ID and URL.
  updateSelfProgresses(
    canvasCourseFilter: CanvasCourseFilterInputGQL
  ): ForceProgressRecalcResultGQL!

  # Create a new empty Learning Library Collection
  createLearningLibraryCollection(
    input: CreateLearningLibraryInput
    accountId: String!
  ): LearningLibraryGQL!

  # Enroll multiple users to multiple learning library collections (creates all user-collection combinations)
  batchEnrollUsersToCollections(
    collectionIds: [String!]!
    userIds: [String!]!
  ): [LearningLibraryCollectionEnrollmentGQL!]!
  deleteWidget(id: String!, userAccountId: String!): Boolean!
  createWidget(input: CreateWidgetInput!, userAccountId: String!): WidgetGQL!
  updateWidget(
    id: String!
    userAccountId: String!
    input: UpdateWidgetInput!
  ): WidgetGQL!
  createWidgetGroup(input: CreateWidgetGroupInput!): WidgetGroupGQL!
  deleteWidgetGroup(id: String!, userAccountId: String!): Boolean!
  updateWidgetGroup(
    id: String!
    userAccountId: String!
    input: UpdateWidgetGroupInput!
  ): WidgetGroupGQL!
  createWidgetAction(
    widgetId: String!
    userAccountId: String!
    inputs: [CreateWidgetActionInput!]!
  ): [WidgetActionGQL!]!
  setWidgetGroupUserData(
    widgetGroupId: String!
    userAccountId: String!
    input: SetWidgetGroupUserDataInput!
  ): WidgetGroupUserDataGQL!

  # Bulk upsert users and metadata
  bulkUpsertMetadata(input: BulkUpsertMetadataInputGQL!): MetadataUsersGql!

  # Remove a leader from all users in the specified root account
  removeLeaderFromAllUsers(input: RemoveLeaderInputGQL!): Boolean!

  #
  #       Answer a prompt using the Cedar AI service
  #
  answerPrompt(prompt: String!): String!

  #
  #       Execute a GraphQL query or mutation on the Redwood service.
  #       This is a generic proxy that forwards any GraphQL operation to Redwood
  #       while preserving user authentication via Canvas JWT.
  #
  executeRedwoodQuery(input: RedwoodQueryInput!): RedwoodResponseGQL!

  # Mark an insight feed message as read.
  markInsightAsRead(insight: String!): Boolean!

  # Mark an insight feed message as dismissed.
  dismissInsights(insights: [String!]!): Boolean!

  #
  #       Encourage learners who aren't engaging enough with the platform by sending
  #       them a motivational email. Returns a handle to the InsightAction.
  #
  encourageLearners(
    insight: String!
    subject: String!
    body: String!
    learners: [String!]!
    sendIndividualMessages: Boolean!
  ): String!

  #
  #       Remind learners to begin a course they were enrolled in by sending them
  #       an email. Returns a handle to the InsightAction.
  #
  remindLearners(
    insight: String!
    subject: String!
    body: String!
    course: String!
    learners: [String!]!
    sendIndividualMessages: Boolean!
  ): String!

  #
  #       Recognize top-skill achievers by sending them a motivational message to
  #       their Canvas Inbox. Returns a handle to the InsightAction.
  #
  praiseLearners(
    insight: String!
    subject: String!
    body: String!
    learners: [String!]!
    sendIndividualMessages: Boolean!
  ): String!
}

input CreateSkillsInputGQL {
  skills: [CreateSkillInputGQL!]!
  skillExtractionId: String
}

input CreateSkillInputGQL {
  name: String!
}

input ChangeTaxonomySkillsInputGQL {
  # Canvas account ID
  accountId: String!

  # List of skills to be created/updated in the taxonomy
  skillsToPersist: [CreateOrUpdateTaxonomySkillInputGQL!]!

  # List of skill IDs to be removed from the taxonomy
  skillsToDelete: [ID!]!

  # List of skills to be merged into a single skill
  merges: [MergeSkillsInputGQL!]!

  # If true, bypasses semantic similarity checks and persists immediately
  skipSimilarityCheck: Boolean! = false
}

input CreateOrUpdateTaxonomySkillInputGQL {
  # Unique identifier for the skill
  id: ID

  # Name of the skill
  name: String!

  # Description of the skill
  description: String!

  # Group ID to which the skill belongs
  groupId: String
}

input MergeSkillsInputGQL {
  # Resulting skill after merging
  mergedSkill: CreateOrUpdateTaxonomySkillInputGQL!

  # List of skill IDs to be merged into the resulting skill
  sourceSkillIds: [ID!]!
}

input AssociateSkillsToLearningObjectsInputGQL {
  # Unique identifier for the course
  courseId: String!
  learningObjects: [CreateOrUpdateAlignmentLearningObjectInputGQL!]!

  # List of skill alignment IDs to delete
  alignmentsToDelete: [ID!]!
}

input CreateOrUpdateAlignmentLearningObjectInputGQL {
  # Unique identifier for the learning object
  id: ID

  # Unique identifier of the content behind the module item
  contentId: String!

  # Type of the learning object
  type: String!

  # List of skill alignments to create or update for the learning object
  alignmentsToPersist: [CreateOrUpdateSkillTaxonomyAlignmentInputGQL!]!
}

input CreateOrUpdateSkillTaxonomyAlignmentInputGQL {
  # Unique identifier for the alignment
  id: ID

  # Unique identifier of the module
  moduleId: String!

  # Unique identifier of the module item
  moduleItemId: String!

  # Unique identifier for the skill
  skillId: ID!

  # Unique identifiers for the proficiency scale values
  proficiencyScaleValues: [ID!]!
}

input UpsertSkillTaxonomyGroupsInputGQL {
  # Canvas account ID
  accountId: String!

  # List of skill taxonomy groups to be upserted
  groups: [UpsertSkillTaxonomyGroupInputGQL!]!
}

input UpsertSkillTaxonomyGroupInputGQL {
  # The unique identifier of the group, if updating an existing one
  id: String

  # The name of the skill taxonomy group
  name: String!
}

input EventInputGQL {
  eventType: String!
  courseId: String
  learningObject: EventLearningObjectInputGQL
  learningObjectType: String
  moduleId: String
  moduleItemId: String
  accountId: String
}

input EventLearningObjectInputGQL {
  id: String!
  type: String!
}

input ContentLibraryInputGQL {
  id: ID!
  externalLinksModuleId: ID
  externalToolsModuleId: ID
  courseId: ID
}

input SyncSettingsInputGQL {
  unpublished: Boolean
  published: Boolean
  notStarted: Boolean
  inProgress: Boolean
  completed: Boolean
  concluded: Boolean
}

input UpdateProgramMetadataGQL {
  id: String!
  name: String!
  publicName: String
  customerId: String
  description: String
  publishStatus: String
  startDate: DateTime
  endDate: DateTime
  variant: String
  courseCompletionCount: Int
  courseEnrollment: CourseEnrollmentType
}

input UpdateProgramRequirementsRequirementGQL {
  dependency: ProgramRequirementCourseInputGQL
  dependent: ProgramRequirementCourseInputGQL!
  isCompletionRequired: Boolean! = true
  isPlaceholder: Boolean! = false
  description: String

  # Course enrollment type for this requirement
  courseEnrollment: String! = "self-enrollment"
}

input ProgramRequirementCourseInputGQL {
  canvasCourseId: String!
  canvasUrl: String!
}

input CanvasCourseFilterInputGQL {
  canvasCourseId: String!
  canvasUrl: String!
}

input CreateLearningLibraryInput {
  # Internal name of the learning library collection
  name: String

  # Public-facing name of the collection
  publicName: String

  # Description of the collection
  description: String
}

input CreateWidgetInput {
  type: String!
  queryParams: WidgetParamsInput!
  position: Int
  widgetGroupId: String
  prismQueryId: String
}

input WidgetParamsInput {
  courseIds: [Float!]
  courseId: Float
  userId: String
  userUuids: [String!]
  maxLateAssignments: Float
  maxMissingAssignments: Float
  minLowScorePercentage: Float
  delayDaysAfterAction: Float
  year: Float
  month: Float
}

input UpdateWidgetInput {
  type: String
  queryParams: WidgetParamsInput
  position: Int
  prismQueryId: String
}

input CreateWidgetGroupInput {
  name: String!
  userAccountId: ID!
  description: String
  widgets: [CreateWidgetInput!]
}

input UpdateWidgetGroupInput {
  name: String
  description: String
  updatedWidgets: [UpdatedWidgetInGroupInput!]
  newWidgets: [CreateWidgetInput!]
}

input UpdatedWidgetInGroupInput {
  id: String!
  position: Int!
}

input CreateWidgetActionInput {
  action: String!
  canvasUserUuid: String!
  courseId: String!
  actionReason: String!
}

input SetWidgetGroupUserDataInput {
  isPinned: Boolean
  lastCheckedAt: DateTime
}

input BulkUpsertMetadataInputGQL {
  # List of users with their metadata to upsert
  users: [MetadataUserInputGQL!]!
}

input MetadataUserInputGQL {
  # UUID of the user's Canvas root account
  canvasRootAccountUuid: ID!

  # User's Canvas UUID
  canvasUserUuid: ID!

  # List of user's leaders Canvas UUIDs. Set to null to delete the leader association.
  leaderCanvasUserUuids: [ID!]

  # List of metadata to upsert for this user
  metadata: [UserMetadataInputGQL!]
}

input UserMetadataInputGQL {
  # Key for the metadata
  key: String!

  # Value for the metadata. Set to null to delete the metadata entry.
  value: String
}

input RemoveLeaderInputGQL {
  # UUID of the leader to be removed from all users
  userUuid: String!
}

input RedwoodQueryInput {
  # GraphQL query or mutation string to execute on Redwood
  query: String!

  # Variables for the GraphQL operation
  variables: JSON

  # Name of the operation to execute (if query contains multiple)
  operationName: String
}
